- JAVA_HOME: must point to installation directory of JDK.
- JRE_HOME: must point to installation directory of JRE.
- CLASSPATH: contains libraries path which JVM will look for.
- PATH: normal environment variable on Windows. (tem varias coisas, umas delas eh o caminho do C:\Program Files\Java\jdk1.8.0_211\bin para rodar JAVAC no cmd)

echo %JAVA_HOME% --> no CMD --> C:\Program Files\Java\jdk1.8.0_211

'javac' is not recognized as an internal or external command, operable program or batch file
It means that javac.exe executable file, which exists in bin directory of JDK installation folder is not added to PATH environment variable. You need to add JAVA_HOME/bin folder in your machine's PATH to solve this error.
--> entrar no environemtn variables do windows, ir no Path e Edit, colocar o caminho do Bin que tem o Javac (C:\Program Files\Java\jdk1.8.0_211\bin)

.JAVA --> arquivo for humans
.CLASS --> compilado pelo JVM

C:\Program Files (x86)\Common Files\Oracle\Java\javapath

-------------------------------------------------------------------------------------------------------------------

java -jar target/algamoney-api-1.0.0-SNAPSHOT.jar

-------------------------------------------------------------------------------------------------------------------



Compiling on the Command line with Java SDK

The primary Java SDK tools, which can be accessed from a command prompt/shell, are:
  javac             // the compiler
  java              // loader/interpreter
Windows versions of these filenames would be:
  javac.exe
  java.exe

Using the javac command
Source code files will end in .java

To compile a source code file, the command format is:
    javac filenmame
Examples:
    javac Example1.java
    javac MyProg.java
    javac Arithmetic.java
    or javac calc/*.java --> tudo dentro do pacote calc
The result will be a file (or files) ending in .class
For every class in a source code file, a full .class file is created

To run a java program, use the java command. Basic format:
   java main-class
In this format, substitute (for main-class above) the name of the class that contains the main() method that is the start of your desired program
Examples:
  java Arithmetic        // runs main() in class Arithmetic
  java Fred              // runs main() in class Fred

-------------------------------------------------------------------------------------------------------------------

java -Xmx100m com.acme.example.ListUsers fred joe bert
The above is going to cause the java command to do the following:

Search for the compiled version of the com.acme.example.ListUsers class.
Load the class.
Check that the class has a main method with signature, return type and modifiers given by public static void main(String[]). (Note, the method argument's name is NOT part of the signature.)
Call that method passing it the command line arguments ("fred", "joe", "bert") as a String[].

-------------------------------------------------------------------------------------------------------------------
foreach FOR EACH forpara

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
for (String i : cars) {
  System.out.println(i);
}

-------------------------------------------------------------------------------------------------------------------
IF ELSE IFELSE ternary tenary

variable = (condition) ? expressionTrue :  expressionFalse;
int time = 20;
String result = (time < 18) ? "Good day." : "Good evening.";

name = city.getName();
if (name == null) name = "N/A";

-------------------------------------------------------------------------------------------------------------------
Difference map and hashmap
HashMap<String, Object> map = new HashMap<String, Object>();  --> will allow the use of any public functions in HashMap (which includes the Map interface).
Map<String, Object> map = new HashMap<String, Object>();      --> will only allow the use of functions defined in the Map interface

Map is an interface that HashMap implements.

The difference is that in the second implementation your reference to the HashMap will only allow the use of functions defined in the Map interface, while the first will allow the use of any public functions in HashMap (which includes the Map interface).

Difference list and arraylist
List<String> al = new ArrayList<String>();
ArrayList<String> al = new ArrayList<String>();

List interface is implemented by the classes of ArrayList, LinkedList, Vector and Stack.

List
List is an Interface.
List interface extends the Collection framework.
List cannot be instantiated.
List interface is used to create a list of elements(objects) which are associated with their index numbers.
List interface creates a collection of elements that are stored in a sequence and they are identified and accessed using the index.

ArrayList
ArrayList is a Class.
ArrayList extends AbstractList class and implements List interface.
ArrayList can be instantiated.
ArrayList class is used to create a dynamic array that contains objects.
ArrayList creates an array of objects where the array can grow dynamically.

Funcoes de Collections

List<Pessoa> pessoas = populaPessoas(); //Cria uma lista de Pessoa
pessoas.stream().forEach(pessoa -> System.out.println(pessoa.getNome()));

List<Pessoa> pessoas = popularPessoas(); //Cria uma lista de Pessoa
Stream<Pessoa> stream = pessoas.stream().filter(pessoa -> pessoa.getNacionalidade().equals("Brasil"));

//media de idades de todas as pessoas q nasceram no Brasil e estao nessa collection
List<Pessoa> pessoas = new Pessoa().populaPessoas();
double media = pessoas.stream().
filter(pessoa -> pessoa.getNacionalidade().equals("Brasil")).
mapToInt(pessoa -> pessoa.getIdade()).
average().getAsDouble();

public Set<Perfil> getPerfis(){ //precisa converter o Numerico para o Perfil equivalente (resgata o INTEGER da tabela)
		//pra cada X [instancia de Perfil] fazer um mapeamento trocando Integer pelo ROLE_bla. Em seguida transforma em SET (Set<Integer>)
		return perfis.stream().map(x -> Perfil.toEnum(x)).collect(Collectors.toSet());   //private Set<Integer> perfis = new HashSet<>();
	}

cli1.getTelefones().addAll(Arrays.asList("27334421", "927334421"));

-------------------------------------------------------------------------------------------------------------------

Lambda

Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.
A lambda expression is a short block of code which takes in parameters and returns a value.

parameter -> expression
(parameter1, parameter2) -> expression
(parameter1, parameter2) -> { code block }

ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(5);
    numbers.add(9);
    numbers.add(8);
    numbers.add(1);
    numbers.forEach( (n) -> { System.out.println(n); } );
    numbers.forEach(  n  -> { if (n%2 == 0) System.out.println(n); });

**** Java program to demonstrate working of lambda expressions
public class Test
{
****    // operation is implemented using lambda expressions
    interface FuncInter1
    {
        int operation(int a, int b);
    }
  
****    // sayMessage() is implemented using lambda expressions
****    // above
    interface FuncInter2
    {
        void sayMessage(String message);
    }
  
****    // Performs FuncInter1's operation on 'a' and 'b'
    private int operate(int a, int b, FuncInter1 fobj)
    {
        return fobj.operation(a, b);
    }
  
    public static void main(String args[])
    {
****        // lambda expression for addition for two parameters
****        // data type for x and y is optional.
****        // This expression implements 'FuncInter1' interface
        FuncInter1 add = (int x, int y) -> x + y;
  
****        // lambda expression multiplication for two parameters
****        // This expression also implements 'FuncInter1' interface
        FuncInter1 multiply = (int x, int y) -> x * y;
  
****        // Creating an object of Test to call operate using
****        // different implementations using lambda Expressions
        Test tobj = new Test();
  
****        // Add two numbers using lambda expression
        System.out.println("Addition is " +
                          tobj.operate(6, 3, add));
  
****        // Multiply two numbers using lambda expression
        System.out.println("Multiplication is " +
                          tobj.operate(6, 3, multiply));
  
****        // lambda expression for single parameter
****        // This expression implements 'FuncInter2' interface
        FuncInter2 fobj = message ->System.out.println("Hello "
                                                 + message);
        fobj.sayMessage("Geek");
    }
}

List<String> novidades = Arrays.asList("Lambdas", "Default Method",
				"Stream API", "Date and Time API");
novidades.forEach(n -> System.out.println(n));

-------------------------------------------------------------------------------------------------------------------

Generics

Ao invez de fazer varias classes abaixo para Integer, String... podemos criar Generics MyClass<T>

-----
public class MyClassDouble{
Double i;
MyClassDouble(Double i){
this.i = i;
}
void printStuff(){
SOUT(i);
}
}

public class MyClass<T>{
T obj;
MyClass (T ob){
obj = ob;
}
}
Pra chamar: 
MyClass<Integer> asd = new MyClass<>(10);
MyClass<Double> qwe = new MyClass<>(10.5);

public class MyClass<T, X>{
T obj;
T objx;
MyClass (T ob, T objx){
obj = ob;
this.objx = objx;
}
}
Para chamar:
MyClass<Integer, Double> asd = new MyClass<>(10, 10.5);

-----

public class Numericos<T extends Number>{   -----> colocou isso pra garantir que oq tem q passar como parametro eh Numer (Integer, Double, Float...)
T ob;
Numericos(T ob){
this.ob = ob;
}
double square(){
return ob.intValue() * ob.doubleValue();  ---> se nao tivesse o extends Number, ia reclamar aqui falando que nao pote T * T [poderiam passar String...]
}
}
Para chamar:
Numericos<Integer> asd = new Numericos<>(4);
SOUT(asd.square());

-----

public class Numericos<T extends Number>{   
T num;
Numericos(T ob){
this.num = ob;
}
boolean absEqual(Numericos<?> objeto){   ====> Antes estava T. Precisa do ? pois nao sabemos qual Type sera, pode ser Double, Float...
if (Math.abs(num.doubleValue()) == Math.abs(objeto.num.doubleValue()))
   return true;
return false;
}
Numericos<Integer> asd = new Numericos<>(4);
Numericos<Double> qwe = new Numericos<>(4.0);
asd.absEqual(qwe);   ----> quando estava com ? reclamou falando q precisava ser INTEGER (pois o primeiro objeto asd transformou o T num em INTEGER (???) ai ele esperava que o qwe fosse INTEGER tbm, mas na verdade ele eh DOUBLE)

-------------------------------------------------------------------------------------------------------------------

Herança heranca inherits inheritance

Extend - Classe Pai Mãe Mae

Extends: In Java, the extends keyword is used to indicate that the class which is being defined is derived from the base class using inheritance. So basically, extends keyword is used to extend the functionality of the parent class to the subclass.
In Java, multiple inheritances are not allowed due to ambiguity. Therefore, a class can extend only one class to avoid ambiguity.

class One {
    public void methodOne()
    {
  
        // Some Functionality
    }
}
  
class Two extends One {
  
    public static void main(String args[])
    {
        Two t = new Two();
  
        // Calls the method one
        // of the above class
        t.methodOne();
    }
}

Usando metodo SUPER.
Chama Construtor da Classe PAI.

Exemplo Classe 

public class Pessoa {

public Pessoa(String nome,String cpf) {
this.setNome(nome);
this.setCPF(cpf);
}

//gets and sets
}

public class Funcionario extends Pessoa{
	public String cargo;
	public Funcionario(String nome, String cpf) {
		super(nome, cpf);
		setCargo(cargo);
	}
	public String getCargo() {
		return cargo;
	}
	public void setCargo(String cargo) {
		this.cargo = cargo;
	}

}

-------------------------------------------------------------------------------------------------------------------

Herança heranca inherits inheritance

Interface

Implements: In Java, the implements keyword is used to implement an interface. An interface is a special type of class which implements a complete abstraction and only contains abstract methods. To access the interface methods, the interface must be implemented by another class with the implements keyword and the methods need to be implemented in the class which is inheriting the properties of the interface. Since an interface is not having the implementation of the methods, a class can implement any number of interfaces at a time.

// Defining an interface
interface One {
    public void methodOne();
}
  
// Defining the second interface
interface Two {
    public void methodTwo();
}
  
// Implementing the two interfaces
class Three implements One, Two {
    public void methodOne()
    {
  
        // Implementation of the method
    }
  
    public void methodTwo()
    {
  
        // Implementation of the method
    }
}

Note: An interface can extend any number of interfaces at a time.

// Defining the interface One
interface One {
    void methodOne();
}
  
// Defining the interface Two
interface Two {
    void methodTwo();
}
  
// Interface extending both the
// defined interfaces
interface Three extends One, Two {
}



-------------------------------------------------------------------------------------------------------------------

O HashMap implementa a interface Map T<K,V>

Quando você instancia um HashMap a sua capacidade inicial é 16, ou seja, você consegue inserir até 16 elementos no Map, sem a necessidade de criar novas posições. O load factor é um atributo que mensura em que momento o HashMap deve dobrar seu tamanho, ou seja, antes que você possa preencher as 16 posições, em algum momento o tamanho do HashMap irá dobrar de 16 para 32
//Tamanho Inicial da Lista
int initialSize = 16;

//Valor do Load Factor
double loadFactor = 0.75;
double sizeToRehash = initialSize * loadFactor;

No nosso caso o resultado será igual a 12. Isso significa
 * que ao inserirmos 12 elementos em nosso HashMap,
 * a lista dobrará de tamanho, ou seja, terá tamanho = 32.
 *
 * Depois o load factor é calculado novamente para o
 * novo tamanho (32) e assim sucessivamente.

----

Map<String,String> example = new HashMap<String,String>();
example.put( "K1", new String( "V1" ));
example.put( "K2", new String( "V2" ));
example.put( "K3", new String( "V3" ));

String keyToSearch = "K1";
if ( example.containsKey( keyToSearch ) ) {
   System.out.println("Valor da Chave "+keyToSearch+
   " = "+example.get(keyToSearch));
   }else{
       System.err.println("Chave não existe");
   }

Percorrer todo o HashMap
for (String key : example.keySet()) {
//Capturamos o valor a partir da chave
    String value = example.get(key);
    System.out.println(key + " = " + value);
}

-------------------------------------------------------------------------------------------------------------------

O método trim() só tira espaço do inicio e fim da String. 

Exemplo: 
String temp = " java ".trim();   
System.out.println(temp);   


Para tirar do meio da String vc pode usar o replace 
String temp = "ja va";   
System.out.print(temp.replace(" ", ""));  

public static boolean isNumeric(String s){  // testa se o campo eh numerico
    try{
        Long.parseLong(s);
        return true;
    }
    catch(NumberFormatException ex){
        return false;
    }
}


if(jTextField1.getText().trim().equals("")) {
           JOptionPane.showMessageDialog(null, "Preecha o Campo");
           return;
        }

-------------------------------------------------------------------------------------------------------------------

Conversao Conversão
Cast parse

Widening Casting (automatically) - converting a smaller type to a larger type size
byte -> short -> char -> int -> long -> float -> double

Narrowing Casting (manually) - converting a larger type to a smaller size type
double -> float -> long -> int -> char -> short -> byte

Double para Integer
double myDouble = 9.78;
int myInt = (int) myDouble; 

1) Convertendo ASCII para String
int i = 64;
String aChar = new Character((char)i).toString();

2) Convertendo números em decimal para binário
int i = 42;
String binstr = Integer.toBinaryString(i);

3) Convertendo um valor booleano para integer
i = (b)?1:0;

4) Convertendo um número decimal para hexadecimal
int i = 42;
String hexstr = Integer.toString(i, 16);

5) Convertendo um Double para um String
double i = 42.0;
String str = Double.toString(i);

6) Convertendo um float para um StringConversion from float to String
float f = 12.0f;
String str = Float.toString(f);

7) Convertendo números em hexadecimal para integer
nt i = Integer.valueOf("B8DA3", 16).intValue();

8) Convertendo um integer para código ASCII
char c = 'A';
int i = (int) c; // Você terá o valor 65

9) Convertendo um número integer para boolean
b = (i != 0);

10) Convertendo de um integer para uma String
int i = 42;
String str = Integer.toString(i);

11) Convertendo de um long para uma String
long l = 42;
String str = Long.toString(l);

12) Convertendo de uma String para Double
double d = Double.valueOf(str).doubleValue();

13) Convertendo String para integer
str = "25";
int i = Integer.valueOf(str).intValue();
int x =Integer.parseInt("9");

14) Convertendo uma String para um float
float f = Float.valueOf(str).floatValue();

15) Convertendo uma String para um long
long l = Long.valueOf(str).longValue();

Classes Pai e Filho Mae e Filha
Animal ---> CAT
Animal animal = new Cat();
((Cat) animal).meow();

-------------------------------------------------------------------------------------------------------------------

Types tipos of Keywords in Java Tipos de Keywords

Static, Final, Abstract, Concrete, Singleton, POJO, Inner

Static class
The class has only static members.
It cannot access the member (non-static) of the outer class.
We cannot create an object of the static class.

Static Method
Static methods are the methods in Java that can be called without creating an object of class. They are referenced by the class name itself or reference to the Object of that class. 

Static Variable
The static variable can be used to refer to the common property of all objects (which is not unique for each object), for example, the company name of employees, college name of students, etc.
The static variable gets memory only once in the class area at the time of class loading.
class Student{  
     int rollno;  
     String name;  
     String college="ITS";  
}  
Suppose there are 500 students in my college, now all instance data members will get memory each time when the object is created. All students have its unique rollno and name, so instance data member is good in such case. Here, "college" refers to the common property of all objects. If we make it static, this field will get the memory only once.

-----

Final class
The purpose of the final class is to make the class immutable like the String class. It is only a way to make the class immutable. Remember that the final class cannot be extended. It also prevents the class from being sub-classed.

Final method
Methods marked as final cannot be overridden. When we design a class and feel that a method shouldnt be overridden, we can make this method final.
Classe pai Dog tem void sound(). Se classe filha PastorAlemao tiver void sound() na calasse, da ruim. 

Final variable
Variables marked as final can't be reassigned. Once a final variable is initialized, it cant be altered.
final int = 1. Nao pode ter depois na classe i = 2.

-----

Abstract Class
The class may or may not contain abstract methods. We cannot create an instance of an abstract class but it can be a subclass. These classes are incomplete, so to complete the abstract class we should extend the abstract classes to a concrete class. When we declare a subclass as abstract then it is necessary to provide the implementation of abstract methods. Therefore, the subclass must also be declared abstract. We can achieve data hiding by using the abstract class.

Abstract class x Interface Class
Abstract class
1) Abstract class can have abstract and non-abstract methods.
2) Abstract class doesn't support multiple inheritance.
3) Abstract class can have final, non-final, static and non-static variables.
4) Abstract class can provide the implementation of interface. (NAO PRECISA IMPLEMENTAR TUDO CASO NAO QUEIRA)
5) The abstract keyword is used to declare abstract class.
6) An abstract class can extend another Java class and implement multiple Java interfaces.
7) An abstract class can be extended using keyword "extends".
8) A Java abstract class can have class members like private, protected, etc.
9)Example:
public abstract class Shape{
public abstract void draw();
}

Interface
Interface can have only abstract methods. Since Java 8, it can have default and static methods also.
Interface supports multiple inheritance.
Interface has only static and final variables.
Interface can't provide the implementation of abstract class.
The interface keyword is used to declare interface.
An interface can extend another Java interface only.
An interface can be implemented using keyword "implements".
Members of a Java interface are public by default.
Example:
public interface Drawable{
void draw();
}

Abstract method
A method without body (no implementation) is known as abstract method. 
public abstract int myMethod(int n1, int n2); --> As you see this has no body.
Abstract methods dont have body, they just have method signature as shown above.
If a regular class extends an abstract class, then the class must have to implement all the abstract methods of abstract parent class or it has to be declared abstract as well. Se a classe filha nao implementar os Abstract Method, da ruim

Abstract variable
Nao tem

-----

Concrete Class
These are the regular Java classes. A derived class that provides the basic implementations for all of the methods that are not already implemented in the base class is known as a concrete class. In other words, it is regular Java classes in which all the methods of an abstract class are implemented. We can create an object of the concrete class directly. Remember that concrete class and abstract class are not the same.

-----

Singleton Class
A class that has only an object at a time is known as a singleton class. Still, if we are trying to create an instance a second time, that newly created instance points to the first instance. If we made any alteration inside the class through any instance, the modification affects the variable of the single instance, also.
Create a private constructor.
Create a static method (by using the lazy initialization) that returns the object of the singleton class.

-----

POJO Class
In Java, POJO stands for Plain Old Java Object. A Java class that contains only private variables, setter and getter is known as POJO class. It is used to define Java objects that increase the reusability and readability of a Java program. The class provides encapsulation. It is widely used in Java because it is easy to understand these classes. POJO class has the following properties:

It does not extend the predefined classes such as Arrays, HttpServlet, etc.
It cannot contain pre-specified annotations.
It cannot implement pre-defined interfaces.
It is not required to add any constructor.
All instance variables must be private.
The getter/ setter methods must be public.

Inner class
Java allows us to define a class within a class and such classes are known as nested classes. It is used to group the classes logically and to achieve encapsulation. The outer class members (including private) can be accessed by the inner class.

-------------------------------------------------------------------------------------------------------------------

Overriding

Declaring a method in sub class which is already present in parent class is known as method overriding. Overriding is done so that a child class can give its own implementation to a method which is already provided by the parent class. In this case the method in parent class is called overridden method and the method in child class is called overriding method. 

No caso, mesmo metodo name com MESMOS PARAMETROS

class Human{
   //Overridden method
   public void eat()
   {
      System.out.println("Human is eating");
   }
}
class Boy extends Human{
   //Overriding method
   public void eat(){
      System.out.println("Boy is eating");
   }
   public static void main( String args[]) {
      Boy obj = new Boy();
      //This will call the child class version of eat()
      obj.eat();
   }
}

-------------------------------------------------------------------------------------------------------------------

Overloading

Method overloading is a feature of Java in which a class has more than one method of the same name and their parameters are different.
No exmeplo abaixo, todos os netodos poderiam ser void com parametros diferentes (int, string, double..)

class CalculateSquare
 { 
public void square()
 { 
System.out.println("No Parameter Method Called");
 } 
public int square( int number )
 {
int square = number * number;
System.out.println("Method with Integer Argument Called:"+square); 
}
public float square( float number ) 
{
 float square = number * number;
 System.out.println("Method with float Argument Called:"+square); 
}
public static void main(String[] args)
  {
    CalculateSquare obj = new CalculateSquare();
    obj.square();
    obj.square(5);   
    obj.square(2.5);   
  }
 }

-------------------------------------------------------------------------------------------------------------------

Assinatura signature

Eh o nome da assinatura mais parametros

public static int nomeMetodo(int x, int y){ }
nomeMetodo(int x, int y) ----> assinatura signature

--------------------------------
ResponseEntity<List<RiscoBacenDTO>> responseEntity = restTemplate.exchange(
					applicationPropertyConfiguration.getMainframe().getUrlGatewayMainframe(), HttpMethod.POST,
					httpEntity(apontamentoDTO), new ParameterizedTypeReference<List<RiscoBacenDTO>>() {
					});

restTemplate.exchange(url, tipo do metodo, request (pode ser httpEntity(apontamentoDTO)), response)

--------------------------------

public HttpHeaders header() {
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		headers.add("Authorization", "Bearer " + safeGuard.generateToken());
		headers.add("x-itau-apikey", applicationPropertyConfiguration.getMainframe().getApiKey());
		headers.add("x-itau-flowID", applicationPropertyConfiguration.getMainframe().getFlowId());
		headers.add("x-itau-correlationID", applicationPropertyConfiguration.getMainframe().getCorrelationId());
		return headers;
	}

--------------------------------

HttpEntity<CF2Body> httpEntity = new HttpEntity<>(cf2Body, header());

Pode ser q seja httpentity com body + header ou so body
httpentity entity = new httpentity(body, headers)
httpentity entity = new httpentity(body)

public HttpEntity<CF2Body> httpEntity(ApontamentoDTO apontamentoDTO) {
		CF2Body cf2Body = CF2Body.builder().transacao(TRANSACTION_NAME).bypasspadright(true)
				.token(applicationPropertyConfiguration.getMainframe().getToken())
				.trancode(montarTrancode(apontamentoDTO))
				.usuario(applicationPropertyConfiguration.getMainframe().getUser()).build();

		HttpEntity<CF2Body> httpEntity = new HttpEntity<>(cf2Body, header());

		return httpEntity;
	}

--------------------------------
I know if you want a list (for example) you create it like:
List<String>
If you want to create a generic type of list you could do it like:
MyList<T>

Codigo abaixo iria compilar e produzir runtime error
ArrayList stringList = new ArrayList();
stringList.add("string");
stringList.add(3.4);
String s = (String) stringList.get(1);

codigo abaixo nao ia compilar
ArrayList<String> stringList = new ArrayList<String>(); // Since Java 7 you can write - new ArrayList<>()
stringList.add("string"); // OK
stringList.add(3.4); // Would not compile!

--------------------------------

nomedaclasse nomeobjetoclasse = nomeDaClasse.builder()
.nomeAtributo1()
.nomeAtributo2()
nomeAtributo3()
.build();

String first = s.substring(0, s.length() / 2);  // gives "How ar


--------------------------------

Se a requisição tiver body, então tem o @RequestBody @Valid SolicitacaoEntradaMobile solicitacaoEntradaMobile
Exemplo localhost:8080/apis/servicos_externos/v1/autorizacoes_registrato
Exemplo Body:
{
	"agencia": "1234",
	"conta": "12345",
	"dac": "6",
	"documento_pessoa": "37945346898",
	"tipo_pessoa": "F",
	"ip": "170.252.196.134"
} 

public ResponseEntity<Object> realizarSolicitacao(
			@RequestBody @Valid SolicitacaoEntradaMobile solicitacaoEntradaMobile,
			@RequestHeader HttpHeaders httpHeaders) {

Se requisição so tiver parm, entao eh @RequestParam("tipo_pessoa"). O documento está em @Valid ApontamentoDTO apontamentoDTO ?
Exemplo: http://localhost:8080/api/v1/riscos_bacen?documento=275755557&tipo_pessoa=&ano_mes_referencia=202012

public ResponseEntity<Object> consultarRiscosBacen(@Valid ApontamentoDTO apontamentoDTO,
			@RequestParam("tipo_pessoa") @TypePerson String tipoPessoa,
			@RequestParam("ano_mes_referencia") String anoMesReferencia, @RequestHeader("authorization") String token) {

--------------------------------

@component eh um generico type for any sprung managed component
@controller, @service e @repository sao especializacao do @component

--------------------------------

Erro no
Mockito.when(tokenGenerator.getValidAuthorizationToken(applicationPropertyConfiguration.getClientId()))
		.thenReturn(jsonObject);
Na parte do applicationPropertyConfiguration.getClientId() estava voltando NULL POINTER
Solução: colocar @Autowired no private ApplicationPropertyConfiguration applicationPropertyConfiguration;

Erro no
BDDMockito.given(safeGuard.validateToken("Bearer sfdasgasfgasdfvstr2345ASWCRVCilulUKKJJJJ"))
     	.willReturn(false);
O comando inteiro acima dava erro de 
consulta-risco-bacen
itau.cf2.consultariscobacen.api.controller.RiscosBarcenControllerTest
testRiscoBacenErroNoToken(itau.cf2.consultariscobacen.api.controller.RiscosBarcenControllerTest)
org.mockito.exceptions.misusing.MissingMethodInvocationException: 
when() requires an argument which has to be 'a method call on a mock'.
For example:
    when(mock.getArticles()).thenReturn(articles);
Solução: colocar @MockBean no private SafeGuard safeGuard;

--------------------------------


javax.net.ssl.keyStore- Location of the Java keystore file containing an application process's own certificate and private key. On Windows, the specified pathname must use forward slashes, /, in place of backslashes.

javax.net.ssl.keyStorePassword - Password to access the private key from the keystore file specified by javax.net.ssl.keyStore. This password is used twice: To unlock the keystore file (store password), and To decrypt the private key stored in the keystore (key password).

javax.net.ssl.trustStore - Location of the Java keystore file containing the collection of CA certificates trusted by this application process (trust store). On Windows, the specified pathname must use forward slashes, /, in place of backslashes, \.

If a trust store location is not specified using this property, the SunJSSE implementation searches for and uses a keystore file in the following locations (in order):

$JAVA_HOME/lib/security/jssecacerts
$JAVA_HOME/lib/security/cacerts
javax.net.ssl.trustStorePassword - Password to unlock the keystore file (store password) specified by javax.net.ssl.trustStore.

javax.net.ssl.trustStoreType - (Optional) For Java keystore file format, this property has the value jks (or JKS). You do not normally specify this property, because its default value is already jks.

javax.net.debug - To switch on logging for the SSL/TLS layer, set this property to ssl.


--------------------------------
http://localhost:8080/orders?id=100

@GetMapping("/orders")
@ResponseBody
public String getOrder(@RequestParam(value = "id", required = true) String id) {
  return "Order ID: " + id;
}

@GetMapping("/orders/{id}")
public String getOrder(@PathVariable String id) {}

@GetMapping("/orders/{id}")
public String getOrder(@PathVariable("id") String orderId) {}

-------------------------------------------------------------------------------------------------------------------

Problema no parent com Augusto CF2

opcao projeto > clean
colocar pluginmanagement no POM (dentro dos plugins e plugin)

-------------------------------------------------------------------------------------------------------------------

Optional - https://medium.com/@racc.costa/optional-no-java-8-e-no-java-9-7c52c4b797f1

A principal proposta deste recurso é encapsular o retorno de métodos e informar se um valor do tipo <T> está presente ou ausente.
= Optional<Cliente> retorno = Optional.empty();

of​ - Retorna um Optional com o valor fornecido, mas o valor não pode ser nulo. Se não tiver certeza de que o valor não é nulo use Optional.ofNullable.
= Optional<Cliente> retorno = Optional.of(buscaCliente(cpf));

ofNullable​ - Se um valor estiver presente, retorna um Optional com o valor , caso contrário, retorna um Optional vazio. Este é um dos métodos mais indicados para criar um Optional.
= Optional<Cliente> retorno = Optional.ofNullable(buscaCliente(cpf));

filter​ - Se um valor estiver presente e o valor corresponder ao predicado retorna um Optional com o valor, se não, retorna um Optional vazio.
= Optional<Cliente> retorno = buscaCliente(cpf).filter(cliente -> !cliente.getNome().isEmpty());

isPresent​ - Se um valor estiver presente retorna true, se não, retorna false.
if (retorno.isPresent()) {
   System.out.println("Cliente encontrado.");
} else {
   System.out.println("Cliente não encontrado.");
}

get​ - Se um valor estiver presente retorna o valor, caso contrário, lança NoSuchElementException. Então para usar get é preciso ter certeza de que o Optional não está vazio.
Optional<Cliente> retorno = Optional.ofNullable(buscaCliente(cpf));
if (retorno.isPresent()) {
   Cliente cliente = retorno.get();
}

ifPresent​ - Se um valor estiver presente, executa a ação no valor, caso contrário, não faz nada.
public void login(String cpf, String senha) {
   dao.buscaPorCPF(cpf).
      ifPresent(cliente -> cliente.realizaLogin(senha));
}

map​ - Se um valor estiver presente retorna um Optinal com o resultado da aplicação da função de mapeamento no valor, caso contrário, retorna um Optional vazio.
if (optCliente.isPresent()) {
   String nome = optCliente.map(Cliente::getNome);
}

flatMap​ - Semelhante a map, se um valor estiver presente, retorna o resultado da aplicação da função de mapeamento no valor, caso contrário retorna um Optional vazio. A diferença é que flatMap pode se aplicado a um mapeamento que também retorna um Optional.
Endereco endereco =
   buscaCliente(cpf).flatMap(Cliente::getEndereco).get();

-------------------------------------------------------------------------------------------------------------------

ModelMapper

public class Pedido {
	private Endereco destino;
	private List<Produto> produtos = new ArrayList<>();
	private Cliente cliente;
}

public class PedidoDto {		
	private String ruaDestino;
	private String numeroDestino;
	private String cidadeDestino;
	private String cepDestino;
	private String cliente;
	private List<ProdutoDto> produtos;
//getters e setters omitidos
}

ModelMapper mapper = new ModelMapper();
PedidoDto dto = mapper.map(pedido, PedidoDto.class); //já foi populado

O ModelMapper é inteligente o suficiente para encontrar o caminho no domínio e chama os getter desde que existam essas informações no DTO. Quando não há como deduzir o caminho correto, é preciso configurá-lo programaticamente. Por exemplo, para pegar o nome do cliente é necessário chamar:

String nome = pedido.getCliente().getNome().getSobreNome(); ==> tem que pegar 2 atributos e juntar em UM SO
peditoDto.setCliente(nome);

Nesse caso o ModelMapper precisa de uma dica pois não tem como deduzir esta chamada. Para tal, existe o PropertyMap que configura programaticamente o mapeamento entre a fonte (source()) e o destino (map()) :

mapper.addMappings(new PropertyMap<Pedido, PedidoDto>() {

 @Override
 protected void configure() {
   String nome = source().getCliente().getNome().getSobreNome();
   map().setCliente(nome);
 }}
);

-------------------------------------------------------------------------------------------------------------------

ENUM ENUMERA

uma enum é um tipo no qual declaramos um conjunto de valores constantes pré-definidos
public enum Turno  {
    MANHA, TARDE, NOITE;
}
Turno  turno = Turno.MANHA;
public enum TipoCliente {
	
	//atribui cod 1 para PESSOAFISICA, aparece (onde?) "Pessoa Fisica"
	PESSOAFISICA(1, "Pessoa Fisica"),
	PESSOAJURIDICA(2, "Pessoa Juridica");
	private int cod;
	private String descricao;
	private TipoCliente(int cod, String descricao) {
		this.cod = cod;
		this.descricao = descricao;
	}
GETS E SETTERS ABAIXO...
public static TipoCliente toEnum(Integer cod) {
		if (cod ==null) {
			return null;
		}
		// busca de todo objeto X nos valores possiveis do TipoCliente
		// se buscar com '1', entao o metodo retorna objeto PESSOAFISICA
		for (TipoCliente x : TipoCliente.values()) {
			if(cod.equals(x.getCod())) {
				return x;
			}
		}
		
		throw new IllegalArgumentException("Id invalido: " + cod);
	}

-------------------------------------------------------------------------------------------------------------------
toString --> transforma o objeto em string
Botao direito > source > generate ToString()
@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append(getProduto().getNome());
		builder.append(", Quantidade: ");
		builder.append(getQuantidade());
		builder.append(", Preco unitario: ");
		builder.append(getPreco());
		builder.append(", Subtotal: ");
		builder.append(getSubValor());
		builder.append("\n");
		return builder.toString();
	}
System.out.println(obj); // Colocando o obj dentro de um PRINTLN, automaticamente chama o toString desse objeto!

-------------------------------------------------------------------------------------------------------------------
NumerFormat - import java.text.NumberFormat;
Formatar de 2000.0 para R$ 2.000,00
NumberFormat nf = NumberFormat.getCurrencyInstance(new Locale("pt", "BR"));
builder.append(nf.format(getSubValor()));

SimpleDateFormat - import java.text.SimpleDateFormat;
Formatar de Wed Jul 14 17:43:31 BRT 2021 para 14/07/2021 05:48:13
SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");
builder.append(sdf.format(getInstante()));

import java.util.Date;
sm.setSentDate(new Date(System.currentTimeMillis())); ---> pega o time do servidor

-------------------------------------------------------------------------------------------------------------------

Envio de email

import org.springframework.mail.SimpleMailMessage; 
SimpleMailMessage --> monta corpo do email, assunto, To e From. [Lembra um pouco do MimeMessageHelper (HTML email)]

Modelo Conceitual

@Override
	public void sendOrderConfirmationEmail(Pedido obj) {
		SimpleMailMessage sm = prepareSipleMailMessageFromPedido(obj);
		sendEmail(sm);
	}

	protected SimpleMailMessage prepareSipleMailMessageFromPedido(Pedido obj) {
		SimpleMailMessage sm = new SimpleMailMessage();
		sm.setTo(obj.getCliente().getEmail());
		sm.setFrom(sender);
		sm.setSubject("Pedido confirmado! Codigo: " + obj.getId());
		sm.setSentDate(new Date(System.currentTimeMillis()));
		sm.setText(obj.toString());
		return sm;
	}

Envio de Email PROD
#Usado pelo MailSender
@Autowired
	private MailSender mailSender;  --> pega as configs abaixo e de fato envia

spring.mail.host=smtp.gmail.com
spring.mail.username=shiromayuji
spring.mail.password=colocar_senha_aqui
spring.mail.properties.mail.smtp.auth = true
spring.mail.properties.mail.smtp.socketFactory.port = 465
spring.mail.properties.mail.smtp.socketFactory.class = javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.smtp.socketFactory.fallback = false
spring.mail.properties.mail.smtp.starttls.enable = true
spring.mail.properties.mail.smtp.ssl.enable = true

import javax.mail.internet.MimeMessage;
MimeMessage  --> envio de email HTML. Quem monta template eh o Thymeleaf ?

Para transformar de um objeto para um MimeMessage, precisa do JavaMailSender
import org.springframework.mail.javamail.JavaMailSender;
MimeMessage mimeMessage = javaMailSender.createMimeMessage();

Para atribuir valores ao MimeMessage precisa do MimeMessageHelper. Lembra um pouco do SimpleMailMessage (Email normal String sem HTML)
import org.springframework.mail.javamail.MimeMessageHelper;
MimeMessageHelper mmh = new MimeMessageHelper(mimeMessage, true);
MimeMessage mimeMessage = javaMailSender.createMimeMessage();
		MimeMessageHelper mmh = new MimeMessageHelper(mimeMessage, true);
		mmh.setTo(obj.getCliente().getEmail());
		mmh.setFrom(sender);
		mmh.setSubject(sender);
		mmh.setSubject("Pedido confirmado! Codigo: " + obj.getId());
		mmh.setSentDate(new Date(System.currentTimeMillis()));
		mmh.setText(htmlFromTemplatePedido(obj), true); // TRUE indica que o conteudo eh HTML


-------------------------------------------------------------------------------------------------------------------

Thymeleaf - Template html que escreve HTML e coloca os elementos que serao preenchidos com os Dados. Igual Angular ou Blade (PHP)
Monta um String povoando as tags

<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>

Criar o template Thymeleaf para o email (código no final deste documento). Criar o arquivo em:
resources/templates/email/confirmacaoPedido.html

Precisa do import org.thymeleaf.context.Context;
Contexto eh necessario para acessar o template HTML e enviar dados pra la
context.setVariable("pedido", obj); // esse "pedido" a esquerda corresponde com apelido la no PEDIDO.id, PEDIDO.cliente.nome, PEDIDO.pagamento.estado...

Para processar esse Template pra retornar o HTML em forma de String
import org.thymeleaf.TemplateEngine;
templateEngine.process("email/confirmacaoPedido", context); // "email/confirmacaoPedido" --> associa com confirmacaoPedido.html que esta no RESOURCE. Nao precisa colocar o .html e nem falar q esta dentro do src/main/resource/ --> Ja pega de la por padrao. Retorna um string

-------------------------------------------------------------------------------------------------------------------

Logger

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
//Tipo static pra nao ter que criar para todo email. So um ja eh o suficiente
	private static final Logger LOG = LoggerFactory.getLogger(MockEmailService.class) --> LOG dessa classe MockEmailService

-------------------------------------------------------------------------------------------------------------------

JWT - json web token
manter infos de autorizacao de usuarios por meio de um token que eh trafegado no cabecalho da requisicao. Armaezena usuario e tempo de expiracao do token de uma forma criptografada e assinada pelo backend. Entao outra pessoa nao consegue gerar outro token pois eh assinado
2 dependencias: artifactId spring-boot-starter-security e jjwt

SPRING-BOOT-STARTER-SECURITY - Security [Mais info e exemplo MAVEN_NOTES]

Ao colocar a dependencia spring-boot-starter-security ja protege os endpoints (ao rodar Postmand, dara 401 not authorized)
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
Precisa ter a classe config
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter{ para definir rotas livres, acesso aos endpoints, endpoints bloqueados, acessos from multiplas fontes, habilitar/desabilitar csrf [ataques STATELESS via sessao armazenando autenticador], etc

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
Hash Cript da senha password
@Autowired
	private BCryptPasswordEncoder pe;
pe.encode(objDto.getSenha())

-------------------------------------------------------------------------------------------------------------------
Para mais infos, ver MAVEN_NOTES.txt

Hibernate is the implementation of JPA. It is the most popular ORM framework, while JPA is an API that defines the specification. Hibernate understands the mapping that we add between objects and tables. It ensures that data is retrieved/ stored from the database based on the mapping. It also provides additional features on the top of the JPA.

Spring Data is a high-level Spring Source project. Its purpose is to unify and easy access to the different kinds of persistence stores, both relational database systems, and NoSQL data stores. That's why the Java Persistent API (JPA) specification and Spring Data JPA are extremely popular
Spring Data JPA handles most of the complexity of JDBC-based (Java Database Connectivity) database access and ORM (Object Relational Mapping). It reduces the boilerplate code required by JPA. It makes the implementation of your persistence layer easier and faster.

-------------------------------------------------------------------------------------------------------------------

Jackson tem o MASHALL e UNMARSHALL

Possui tambem validacao e @Types
@Bean
	public Jackson2ObjectMapperBuilder objectMapperBuilder() {
		Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder() {
			public void configure(ObjectMapper objectMapper) {
				objectMapper.registerSubtypes(PagamentoComCartao.class);
				objectMapper.registerSubtypes(PagamentoComBoleto.class);
				super.configure(objectMapper);
			}
		};
		return builder;
	}

-------------------------------------------------------------------------------------------------------------------

H2 e MYSQL Configs ver no Maven Notes

application properties TEST:

server.port=${port:8081}
spring.datasource.url=jdbc:h2:mem:testdb 
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.show-sql=true 
spring.jpa.properties.hibernate.format_sql=true 


application properties DEV:
spring.datasource.url=jdbc:mysql://localhost:3306/curso_spring?serverTimezone=UTC
#spring.datasource.url=jdbc:mysql://b107017d8b964b:cc1f0b1a@us-cdbr-east-04.cleardb.com/heroku_c5b6f3779661a9c?reconnect=true
spring.datasource.username=root
spring.datasource.password=